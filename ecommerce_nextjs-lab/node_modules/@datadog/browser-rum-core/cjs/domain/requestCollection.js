"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startRequestCollection = startRequestCollection;
exports.trackXhr = trackXhr;
exports.trackFetch = trackFetch;
const browser_core_1 = require("@datadog/browser-core");
const resourceUtils_1 = require("./resource/resourceUtils");
const tracer_1 = require("./tracing/tracer");
let nextRequestIndex = 1;
function startRequestCollection(lifeCycle, configuration, sessionManager) {
    const tracer = (0, tracer_1.startTracer)(configuration, sessionManager);
    trackXhr(lifeCycle, configuration, tracer);
    trackFetch(lifeCycle, tracer);
}
function trackXhr(lifeCycle, configuration, tracer) {
    const subscription = (0, browser_core_1.initXhrObservable)(configuration).subscribe((rawContext) => {
        const context = rawContext;
        if (!(0, resourceUtils_1.isAllowedRequestUrl)(context.url)) {
            return;
        }
        switch (context.state) {
            case 'start':
                tracer.traceXhr(context, context.xhr);
                context.requestIndex = getNextRequestIndex();
                lifeCycle.notify(7 /* LifeCycleEventType.REQUEST_STARTED */, {
                    requestIndex: context.requestIndex,
                    url: context.url,
                });
                break;
            case 'complete':
                tracer.clearTracingIfNeeded(context);
                lifeCycle.notify(8 /* LifeCycleEventType.REQUEST_COMPLETED */, {
                    duration: context.duration,
                    method: context.method,
                    requestIndex: context.requestIndex,
                    spanId: context.spanId,
                    startClocks: context.startClocks,
                    status: context.status,
                    traceId: context.traceId,
                    traceSampled: context.traceSampled,
                    type: "xhr" /* RequestType.XHR */,
                    url: context.url,
                    xhr: context.xhr,
                    isAborted: context.isAborted,
                    handlingStack: context.handlingStack,
                });
                break;
        }
    });
    return { stop: () => subscription.unsubscribe() };
}
function trackFetch(lifeCycle, tracer) {
    const subscription = (0, browser_core_1.initFetchObservable)().subscribe((rawContext) => {
        const context = rawContext;
        if (!(0, resourceUtils_1.isAllowedRequestUrl)(context.url)) {
            return;
        }
        switch (context.state) {
            case 'start':
                tracer.traceFetch(context);
                context.requestIndex = getNextRequestIndex();
                lifeCycle.notify(7 /* LifeCycleEventType.REQUEST_STARTED */, {
                    requestIndex: context.requestIndex,
                    url: context.url,
                });
                break;
            case 'resolve':
                waitForResponseToComplete(context, (duration) => {
                    tracer.clearTracingIfNeeded(context);
                    lifeCycle.notify(8 /* LifeCycleEventType.REQUEST_COMPLETED */, {
                        duration,
                        method: context.method,
                        requestIndex: context.requestIndex,
                        responseType: context.responseType,
                        spanId: context.spanId,
                        startClocks: context.startClocks,
                        status: context.status,
                        traceId: context.traceId,
                        traceSampled: context.traceSampled,
                        type: "fetch" /* RequestType.FETCH */,
                        url: context.url,
                        response: context.response,
                        init: context.init,
                        input: context.input,
                        isAborted: context.isAborted,
                        handlingStack: context.handlingStack,
                    });
                });
                break;
        }
    });
    return { stop: () => subscription.unsubscribe() };
}
function getNextRequestIndex() {
    const result = nextRequestIndex;
    nextRequestIndex += 1;
    return result;
}
function waitForResponseToComplete(context, callback) {
    const clonedResponse = context.response && (0, browser_core_1.tryToClone)(context.response);
    if (!clonedResponse || !clonedResponse.body) {
        // do not try to wait for the response if the clone failed, fetch error or null body
        callback((0, browser_core_1.elapsed)(context.startClocks.timeStamp, (0, browser_core_1.timeStampNow)()));
    }
    else {
        (0, browser_core_1.readBytesFromStream)(clonedResponse.body, () => {
            callback((0, browser_core_1.elapsed)(context.startClocks.timeStamp, (0, browser_core_1.timeStampNow)()));
        }, {
            bytesLimit: Number.POSITIVE_INFINITY,
            collectStreamBody: false,
        });
    }
}
//# sourceMappingURL=requestCollection.js.map