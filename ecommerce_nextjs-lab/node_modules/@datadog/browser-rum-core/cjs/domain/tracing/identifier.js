"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTraceIdentifier = createTraceIdentifier;
exports.createSpanIdentifier = createSpanIdentifier;
exports.clearIdentifierImplementationCache = clearIdentifierImplementationCache;
exports.areBigIntIdentifiersSupported = areBigIntIdentifiersSupported;
exports.toPaddedHexadecimalString = toPaddedHexadecimalString;
const browser_core_1 = require("@datadog/browser-core");
const crypto_1 = require("../../browser/crypto");
function createTraceIdentifier() {
    return createIdentifier(64);
}
function createSpanIdentifier() {
    return createIdentifier(63);
}
let createIdentifierImplementationCache;
function clearIdentifierImplementationCache() {
    createIdentifierImplementationCache = undefined;
}
function createIdentifier(bits) {
    if (!createIdentifierImplementationCache) {
        createIdentifierImplementationCache =
            (0, browser_core_1.isExperimentalFeatureEnabled)(browser_core_1.ExperimentalFeature.CONSISTENT_TRACE_SAMPLING) && areBigIntIdentifiersSupported()
                ? createIdentifierUsingBigInt
                : createIdentifierUsingUint32Array;
    }
    return createIdentifierImplementationCache(bits);
}
function areBigIntIdentifiersSupported() {
    try {
        crypto.getRandomValues(new BigUint64Array(1));
        return true;
    }
    catch (_a) {
        return false;
    }
}
function createIdentifierUsingBigInt(bits) {
    let id = crypto.getRandomValues(new BigUint64Array(1))[0];
    if (bits === 63) {
        // eslint-disable-next-line no-bitwise
        id >>= BigInt('1');
    }
    return id;
}
// TODO: remove this when all browser we support have BigInt support
function createIdentifierUsingUint32Array(bits) {
    const buffer = (0, crypto_1.getCrypto)().getRandomValues(new Uint32Array(2));
    if (bits === 63) {
        // eslint-disable-next-line no-bitwise
        buffer[buffer.length - 1] >>>= 1; // force 63-bit
    }
    return {
        toString(radix = 10) {
            let high = buffer[1];
            let low = buffer[0];
            let str = '';
            do {
                const mod = (high % radix) * 4294967296 + low;
                high = Math.floor(high / radix);
                low = Math.floor(mod / radix);
                str = (mod % radix).toString(radix) + str;
            } while (high || low);
            return str;
        },
    };
}
function toPaddedHexadecimalString(id) {
    const traceId = id.toString(16);
    // TODO: replace with String.prototype.padStart when we drop IE11 support
    return Array(17 - traceId.length).join('0') + traceId;
}
//# sourceMappingURL=identifier.js.map