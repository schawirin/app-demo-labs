"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTracingOption = isTracingOption;
exports.clearTracingIfNeeded = clearTracingIfNeeded;
exports.startTracer = startTracer;
exports.isTracingSupported = isTracingSupported;
const browser_core_1 = require("@datadog/browser-core");
const crypto_1 = require("../../browser/crypto");
const identifier_1 = require("./identifier");
const sampler_1 = require("./sampler");
function isTracingOption(item) {
    const expectedItem = item;
    return ((0, browser_core_1.getType)(expectedItem) === 'object' &&
        (0, browser_core_1.isMatchOption)(expectedItem.match) &&
        Array.isArray(expectedItem.propagatorTypes));
}
/**
 * Clear tracing information to avoid incomplete traces. Ideally, we should do it when the
 * request did not reach the server, but the browser does not expose this. So, we clear tracing
 * information if the request ended with status 0 without being aborted by the application.
 *
 * Reasoning:
 *
 * * Applications are usually aborting requests after a bit of time, for example when the user is
 * typing (autocompletion) or navigating away (in a SPA). With a performant device and good
 * network conditions, the request is likely to reach the server before being canceled.
 *
 * * Requests aborted otherwise (ex: lack of internet, CORS issue, blocked by a privacy extension)
 * are likely to finish quickly and without reaching the server.
 *
 * Of course, it might not be the case every time, but it should limit having incomplete traces a
 * bit.
 * */
function clearTracingIfNeeded(context) {
    if (context.status === 0 && !context.isAborted) {
        context.traceId = undefined;
        context.spanId = undefined;
        context.traceSampled = undefined;
    }
}
function startTracer(configuration, sessionManager) {
    return {
        clearTracingIfNeeded,
        traceFetch: (context) => injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders) => {
            var _a;
            if (context.input instanceof Request && !((_a = context.init) === null || _a === void 0 ? void 0 : _a.headers)) {
                context.input = new Request(context.input);
                Object.keys(tracingHeaders).forEach((key) => {
                    ;
                    context.input.headers.append(key, tracingHeaders[key]);
                });
            }
            else {
                context.init = (0, browser_core_1.shallowClone)(context.init);
                const headers = [];
                if (context.init.headers instanceof Headers) {
                    context.init.headers.forEach((value, key) => {
                        headers.push([key, value]);
                    });
                }
                else if (Array.isArray(context.init.headers)) {
                    context.init.headers.forEach((header) => {
                        headers.push(header);
                    });
                }
                else if (context.init.headers) {
                    Object.keys(context.init.headers).forEach((key) => {
                        headers.push([key, context.init.headers[key]]);
                    });
                }
                context.init.headers = headers.concat((0, browser_core_1.objectEntries)(tracingHeaders));
            }
        }),
        traceXhr: (context, xhr) => injectHeadersIfTracingAllowed(configuration, context, sessionManager, (tracingHeaders) => {
            Object.keys(tracingHeaders).forEach((name) => {
                xhr.setRequestHeader(name, tracingHeaders[name]);
            });
        }),
    };
}
function injectHeadersIfTracingAllowed(configuration, context, sessionManager, inject) {
    if (!isTracingSupported() || !sessionManager.findTrackedSession()) {
        return;
    }
    const tracingOption = configuration.allowedTracingUrls.find((tracingOption) => (0, browser_core_1.matchList)([tracingOption.match], context.url, true));
    if (!tracingOption) {
        return;
    }
    const traceId = (0, identifier_1.createTraceIdentifier)();
    context.traceSampled = (0, sampler_1.isTraceSampled)(traceId, configuration.traceSampleRate);
    const shouldInjectHeaders = context.traceSampled || configuration.traceContextInjection === browser_core_1.TraceContextInjection.ALL;
    if (!shouldInjectHeaders) {
        return;
    }
    context.traceId = traceId;
    context.spanId = (0, identifier_1.createSpanIdentifier)();
    inject(makeTracingHeaders(context.traceId, context.spanId, context.traceSampled, tracingOption.propagatorTypes));
}
function isTracingSupported() {
    return (0, crypto_1.getCrypto)() !== undefined;
}
/**
 * When trace is not sampled, set priority to '0' instead of not adding the tracing headers
 * to prepare the implementation for sampling delegation.
 */
function makeTracingHeaders(traceId, spanId, traceSampled, propagatorTypes) {
    const tracingHeaders = {};
    propagatorTypes.forEach((propagatorType) => {
        switch (propagatorType) {
            case 'datadog': {
                Object.assign(tracingHeaders, {
                    'x-datadog-origin': 'rum',
                    'x-datadog-parent-id': spanId.toString(),
                    'x-datadog-sampling-priority': traceSampled ? '1' : '0',
                    'x-datadog-trace-id': traceId.toString(),
                });
                break;
            }
            // https://www.w3.org/TR/trace-context/
            case 'tracecontext': {
                Object.assign(tracingHeaders, {
                    traceparent: `00-0000000000000000${(0, identifier_1.toPaddedHexadecimalString)(traceId)}-${(0, identifier_1.toPaddedHexadecimalString)(spanId)}-0${traceSampled ? '1' : '0'}`,
                    tracestate: `dd=s:${traceSampled ? '1' : '0'};o:rum`,
                });
                break;
            }
            // https://github.com/openzipkin/b3-propagation
            case 'b3': {
                Object.assign(tracingHeaders, {
                    b3: `${(0, identifier_1.toPaddedHexadecimalString)(traceId)}-${(0, identifier_1.toPaddedHexadecimalString)(spanId)}-${traceSampled ? '1' : '0'}`,
                });
                break;
            }
            case 'b3multi': {
                Object.assign(tracingHeaders, {
                    'X-B3-TraceId': (0, identifier_1.toPaddedHexadecimalString)(traceId),
                    'X-B3-SpanId': (0, identifier_1.toPaddedHexadecimalString)(spanId),
                    'X-B3-Sampled': traceSampled ? '1' : '0',
                });
                break;
            }
        }
    });
    return tracingHeaders;
}
//# sourceMappingURL=tracer.js.map