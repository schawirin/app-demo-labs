"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LCP_MAXIMUM_DELAY = void 0;
exports.trackLargestContentfulPaint = trackLargestContentfulPaint;
const browser_core_1 = require("@datadog/browser-core");
const performanceObservable_1 = require("../../../browser/performanceObservable");
const getSelectorFromElement_1 = require("../../getSelectorFromElement");
// Discard LCP timings above a certain delay to avoid incorrect data
// It happens in some cases like sleep mode or some browser implementations
exports.LCP_MAXIMUM_DELAY = 10 * browser_core_1.ONE_MINUTE;
/**
 * Track the largest contentful paint (LCP) occurring during the initial View.  This can yield
 * multiple values, only the most recent one should be used.
 * Documentation: https://web.dev/lcp/
 * Reference implementation: https://github.com/GoogleChrome/web-vitals/blob/master/src/onLCP.ts
 */
function trackLargestContentfulPaint(configuration, firstHidden, eventTarget, callback) {
    // Ignore entries that come after the first user interaction. According to the documentation, the
    // browser should not send largest-contentful-paint entries after a user interact with the page,
    // but the web-vitals reference implementation uses this as a safeguard.
    let firstInteractionTimestamp = Infinity;
    const { stop: stopEventListener } = (0, browser_core_1.addEventListeners)(configuration, eventTarget, ["pointerdown" /* DOM_EVENT.POINTER_DOWN */, "keydown" /* DOM_EVENT.KEY_DOWN */], (event) => {
        firstInteractionTimestamp = event.timeStamp;
    }, { capture: true, once: true });
    let biggestLcpSize = 0;
    const performanceLcpSubscription = (0, performanceObservable_1.createPerformanceObservable)(configuration, {
        type: performanceObservable_1.RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT,
        buffered: true,
    }).subscribe((entries) => {
        const lcpEntry = (0, browser_core_1.findLast)(entries, (entry) => entry.entryType === performanceObservable_1.RumPerformanceEntryType.LARGEST_CONTENTFUL_PAINT &&
            entry.startTime < firstInteractionTimestamp &&
            entry.startTime < firstHidden.timeStamp &&
            entry.startTime < exports.LCP_MAXIMUM_DELAY &&
            // Ensure to get the LCP entry with the biggest size, see
            // https://bugs.chromium.org/p/chromium/issues/detail?id=1516655
            entry.size > biggestLcpSize);
        if (lcpEntry) {
            let lcpTargetSelector;
            if (lcpEntry.element) {
                lcpTargetSelector = (0, getSelectorFromElement_1.getSelectorFromElement)(lcpEntry.element, configuration.actionNameAttribute);
            }
            callback({
                value: lcpEntry.startTime,
                targetSelector: lcpTargetSelector,
                resourceUrl: lcpEntry.url,
            });
            biggestLcpSize = lcpEntry.size;
        }
    });
    return {
        stop: () => {
            stopEventListener();
            performanceLcpSubscription.unsubscribe();
        },
    };
}
//# sourceMappingURL=trackLargestContentfulPaint.js.map